#!/bin/sh

exec awk '
# show usage and exit
function usage() {
	print "usage: calendar [-d] [-A num] [-B num] -t [yyyymmdd] [file ...]" >"/dev/stderr"
	error = 1
	exit 1
}

# show error and exit
function err(s) {
	printf "calendar: %s\n", s >"/dev/stderr"
	error = 1
	exit 1
}

# thanks https://github.com/e36freak
function getopts(optstring, longarr,    opt, trimmed, hasarg, repeat) {
	hasarg = repeat = 0
	optarg = ""
	optind++

	# return -1 if the current arg is not an option or there are no args left
	if (ARGV[optind] !~ /^-/ || optind >= ARGC) {
		return -1
	}

	# if option is "--" (end of options), delete arg and return -1
	if (ARGV[optind] == "--") {
		for (i=1; i<=optind; i++) {
			delete ARGV[i]
		}
		return -1
	}

	# remove the hyphen, and get just the option letter
	opt = substr(ARGV[optind], 2, 1)
	# set trimmed to whatevers left
	trimmed = substr(ARGV[optind], 3)

	# invalid option
	if (!index(optstring, opt)) {
		printf("invalid option -- '%s'\n", opt) > "/dev/stderr"
		return "?"
	}

	# if there is more to the argument than just -o
	if (length(trimmed)) {
		# if option requires an argument, set the rest to optarg and hasarg to 1
		if (index(optstring, opt ":")) {
			optarg = trimmed
			hasarg = 1

		# otherwise, prepend a hyphen to the rest and set repeat to 1, so the
		# same arg is processed again without the first option
		} else {
			ARGV[optind] = "-" trimmed
			repeat = 1
		}
	}

	# set optname by prepending a hypen to opt
	optname = "-" opt

	# if the option requires an arg and hasarg is 0
	if (index(optstring, opt ":") && !hasarg) {
		# increment optind, check if no arguments are left
		if (++optind >= ARGC) {
		  printf("option requires an argument -- '%s'\n", optname) > "/dev/stderr"
		  return "?"
		}

		# set optarg
		optarg = ARGV[optind]

	# if repeat is set, decrement optind so we process the same arg again
	# mutually exclusive to needing an argument, otherwise hasarg would be set
	} else if (repeat) {
		optind--
	}

	# delete all arguments up to this point, just to make sure
	for (i=1; i<=optind; i++) {
	  delete ARGV[i]
	}

	# return the option letter
	return opt
}

# increment date 1 day
function incdate() {
	if (++day > daysinmonth[isleap(year), month]) {
		day = 1
		if (++month > 12) {
			month = 1
			year++
		}
	}
	wday = (wday + 1) % NDAYS
	if (wday == 0) {
		wday = NDAYS
	}
}

# check if year is leap year
function isleap(y) {
	return (!(y % 4) && (y % 100) || !(y % 400))
}

# get date pattern
function getpattern(    i, s, t, y, m, d, p, n, u) {
	# y = year
	# m = month
	# d = month day
	# p = (positive) week number from beginning of month
	# n = (negative) week number from end of month
	# u = week day (1 = monday to 7 = sunday)
	s = $0
	if (npatt++ > 0) {                      # remove leading comma
		if (match(s, /^,[ \t]*/)) {
			s = substr(s, RLENGTH + 1)
		} else {
			return ""
		}
	}
	if (match(s, /^[A-Za-z]+[ \t]/)) {      # check for special dates
		t = tolower(substr(s, 1, RLENGTH - 1))
		if (t == "easter") {
			s = substr(s, RLENGTH + 1)
			sub(/^[\t ]+/, "", s)
			$0 = s
			return "easter"
		}
	}
	y = m = d = p = n = u = 0
	if (match(s, /^[0-9]+[\/.-]/)) {        # check numeric month and year
		m = substr(s, 1, RLENGTH - 1)
		if (m == 0)
			return ""
		s = substr(s, RLENGTH + 1)
		if (match(s, /^[0-9]+[\/.-]/)) {
			y = m
			m = substr(s, 1, RLENGTH - 1)
			if (m == 0)
				return ""
			s = substr(s, RLENGTH + 1)
		}
	}
	if (m == 0) {                           # check month name
		match(s, /^[A-Za-z]+/)
		t = tolower(substr(s, 1, 3))
		for (i = 1; i <= NMONTHS; i++) {
			if (t == months[i]) {
				if (substr(s, RLENGTH + 1) !~ /[\/.-]/) 
					return ""
				m = i
				s = substr(s, RLENGTH + 2)
				break
			}
		}
	}
	if (match(s, /^[0-9]+/)) {              # check numeric month day
		d = substr(s, 1, RLENGTH)
		s = substr(s, RLENGTH + 1)
	}
	if (match(s, /^[A-Za-z]+/)) {           # check week day name
		t = tolower(substr(s, 1, 3))
		for (i = 1; i <= NDAYS; i++) {
			if (t == days[i]) {
				u = i
				s = substr(s, RLENGTH + 1)
				break
			}
		}
		if (u != 0) {
			if (match(s, /^[+][1-5]/)) {
				p = substr(s, 2, 1)
				s = substr(s, 3)
			} else if (match(s, /^-[1-5]/)) {
				n = substr(s, 2, 1)
				s = substr(s, 3)
			}
		}
	}
	if (d == 0 && u == 0)                   # if no day set, pattern is wrong
		return ""
	sub(/^[\t ]+/, "", s)
	$0 = s
	y = (y == 0) ?  y = ".*" : sprintf("%d", y)
	m = (m == 0) ?  m = ".." : sprintf("%02d", m)
	d = (d == 0) ?  d = ".." : sprintf("%02d", d)
	p = (p == 0) ?  p = "." : p
	n = (n == 0) ?  n = "." : n
	u = (u == 0) ?  u = "." : u
	return sprintf("%s-%s-%s-%s-%s-%s", y, m, d, p, n, u)
}

function calceaster(    a, b, c, d, e,f, g, h, i, k, l, m, n, p) {
	a = int(year % 19)
	b = int(year / 100)
	c = int(year % 100)
	d = int(b / 4)
	e = int(b % 4)
	f = int((b + 8) / 25)
	g = int((b + 1 - f) / 3)
	h = int(((19 * a) + 15 + b - (d + g)) % 30)
	i = int(c / 4)
	k = int(c % 4)
	l = int((32 + 2 * e + 2 * i - (h + k)) % 7)
	m = int((a + 11 * h + 22 * l) / 451)
	n = int((h + l + 114 - (7 * m)) / 31)
	p = int((h + l + 114 - (7 * m)) % 31 + 1)
	if (isleap(year))
		p++
	easter_month = n
	easter_day = p
}

# get week of the month for given date
function getwofm(y, m, d) {
	return strftime("%W", mktime(y " " m " " d " 12 00 00")) - strftime("%W", mktime(y " " m " 1 12 00 00")) + 1
}

# get date string (in format y-m-d-p-n-u) for current date
function getdate(    last, p, n) {
	last = getwofm(year, month, daysinmonth[isleap(year), month])
	p = getwofm(year, month, day)
	n = -1 * (p - last - 1)
	return sprintf("%d-%02d-%02d-%1d-%1d-%1d", year, month, day, p, n, wday)
}

# check if date pattern matches date
function patternmatch(patt, date) {
	if (patt ~ "easter" && month == easter_month && day == easter_day)
		return 1
	return date ~ patt
}

BEGIN {
	CALENDARFILE="calendar"

	SECSPERDAY = 24 * 60 * 60

	daysinmonth[0, 1] =  daysinmonth[1, 1] =  31
	daysinmonth[0, 2] =                       28
	daysinmonth[1, 2] =                       29
	daysinmonth[0, 3] =  daysinmonth[1, 3] =  31
	daysinmonth[0, 4] =  daysinmonth[1, 4] =  30
	daysinmonth[0, 5] =  daysinmonth[1, 5] =  31
	daysinmonth[0, 6] =  daysinmonth[1, 6] =  30
	daysinmonth[0, 7] =  daysinmonth[1, 7] =  31
	daysinmonth[0, 8] =  daysinmonth[1, 8] =  31
	daysinmonth[0, 9] =  daysinmonth[1, 9] =  30
	daysinmonth[0, 10] = daysinmonth[1, 10] = 31
	daysinmonth[0, 11] = daysinmonth[1, 11] = 30
	daysinmonth[0, 12] = daysinmonth[1, 12] = 31

	NMONTHS = 12
	months[1] =  "jan"
	months[2] =  "feb"
	months[3] =  "mar"
	months[4] =  "apr"
	months[5] =  "may"
	months[6] =  "jun"
	months[7] =  "jul"
	months[8] =  "aug"
	months[9] =  "sep"
	months[10] = "oct"
	months[11] = "nov"
	months[12] = "dec"
	outmonths[1] =  "January"
	outmonths[2] =  "February"
	outmonths[3] =  "March"
	outmonths[4] =  "April"
	outmonths[5] =  "May"
	outmonths[6] =  "June"
	outmonths[7] =  "July"
	outmonths[8] =  "August"
	outmonths[9] =  "September"
	outmonths[10] = "October"
	outmonths[11] = "November"
	outmonths[12] = "December"

	NDAYS = 7
	days[1] = "mon"
	days[2] = "tue"
	days[3] = "wed"
	days[4] = "thu"
	days[5] = "fri"
	days[6] = "sat"
	days[7] = "sun"
	outdays[1] = "Monday"
	outdays[2] = "Tuesday"
	outdays[3] = "Wednesday"
	outdays[4] = "Thursday"
	outdays[5] = "Friday"
	outdays[6] = "Saturday"
	outdays[7] = "Sunday"

	time  = systime();
	year  = strftime("%Y", time) + 0
	month = strftime("%m", time) + 0
	day   = strftime("%d", time) + 0
	time  = mktime(year " " month " " day " 12 00 00")
	while ((c = getopts("A:B:dt:")) != -1) {
		if (c == "A") {
			after = optarg + 0
		} else if (c == "B") {
			before = optarg + 0
		} else if (c == "d") {
			printdate = 1
		} else if (c == "t") {
			today = optarg + 0
		} else {
			usage()
		}
	}
	len = length(today)
	if (today ~ /^..$/) {
		time = mktime(year " " month " " today " 12 00 00")
	} else if (today ~ /^....$/) {
		s = substr(today, 1, 2) " " substr(today, 3, 2)
		time = mktime(year " " s " 12 00 00")
	} else if (today ~ /^.*....$/) {
		s = substr(today, 1, len - 4) " " substr(today, len - 3, 2) " " substr(today, len - 1, 2)
		time = mktime(s " 12 00 00")
	}
	if (time < 0) {
		err("invalid time")
	}
	time += before * SECSPERDAY
	year  = strftime("%Y", time) + 0
	month = strftime("%m", time) + 0
	day   = strftime("%d", time) + 0
	wday  = strftime("%u", time) + 0
	if (!after) {
		if (wday == 5) {
			after = 3
		} else if (wday == 6) {
			after = 2
		} else {
			after = 1
		}
	}
	if (optind == ARGC) {   # no argument provided, read default calendar file
		CALENDARDIR = ENVIRON["CALENDAR_DIR"]
		if (system("test -r " CALENDARFILE) != 0 && CALENDARDIR) {
			CALENDARFILE = CALENDARDIR "/" CALENDARFILE
		}
		ARGV[ARGC++] = CALENDARFILE
	}
}

{
	patt = ""
	npatt = 0
	while ((s = getpattern()))
		patt = patt (patt ? "|" : "") s
	if (patt) {
		nevents++
		events[nevents, "patt"] = patt
		events[nevents, "name"] = $0
	}
}

END {
	if (error)
		exit error
	for (i = 0; i <= after; i++) {
		if (prevyear != year) {         # compute movable feasts
			calceaster()
			prevyear = year
		}
		date = getdate()
		if (printdate)
			outdate = sprintf("%-9s  %02d %s %02d", outdays[wday], day, outmonths[month], day)
		else
			outdate = sprintf("%s %02d ", substr(outmonths[month], 1, 3), day)
		delete a
		n = 0
		for (j = 1; j <= nevents; j++) {
			if (patternmatch(events[j, "patt"], date)) {
				a[++n] = events[j, "name"]
			}
		}
		if (n) {
			if (printdate)
				print outdate
			for (j = 1; j <= n; j++) {
				print (printdate ? "\t" : outdate) a[j]
			}
		}
		incdate()
	}
}
' "$@"
